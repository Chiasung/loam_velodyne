ScanRegistration源码分析
=========================================
.. Note::
   本文仅供参考

LOAM的整体思想就是将复杂的SLAM问题分为：
1. 高频的运动估计； 
2. 低频（低一个数量级）的环境建图。
整个系统的框架如图：

.. image:: ../images/arch.jpg
   :align: center

Lidar接收数据，首先进行Point Cloud Registration，Lidar Odometry以10Hz的频率进行运动估计和坐标转换，Lidar Mapping以1Hz的频率构建三维地图。这样做主要是为了保证系统的实时性。下面再来看看代码的框架图：

.. image:: ../images/node_graph.jpg
   :align: center

这一节点主要功能是：对点云和IMU数据进行预处理，用于特征点的配准。所以这个节点实际上就是一个计算准备的过程，其实就做了一个工作：那就是根据点的曲率c来将点划分为不同的类别（边/面特征或不是特征），公式如下：

.. image:: ../images/cuvature.jpg
   :align: center


具体代码实现（这里的实现和代码看起来有点不一致）：

从main函数看出，该节点通过订阅器subLaserCloud订阅 /svelodyne_points消息，并由回调函数laserCloudHandler进行处理，订阅器缓存区大小为2；订阅器subImu订阅 /imu/data消息，由回调函数imuHanler处理，缓存区大小为50。此外，该节点通过发布器pubLaserCloud发布以不同线分类的点云的指针/velodyne_cloud_2，缓存区大小为2；发布器pubCornerPointSharp和pubCornerPointLessSharp发布特征角点 /laser_cloud_sharp和/laser_cloud_less_sharp，缓存区大小为2；发布器pubSurfPointFlat和pubSurfPointLessFlat发布特征角点 /laser_cloud_flat和/laser_cloud_less_flat，缓存区大小为2；发布器pubImuTrans发布IMU信息 /imu_trans，缓存区大小为5。下面从两个回调函数分别介绍这个节点的代码。

该回调函数是这一节点的重点部分，主要功能是对接收到的点云进行预处理，完成分类。具体分类内容为：一是按照不同线，将点云保存在点云指针中；二是对其进行特征分类。

首先剔除异常点并计算起始和终止位置的角度：


然后遍历所有点，根据角度计算结果将其划分为不同的线：计算角度-->计算起始和终止位置-->插入IMU数据-->将点插入容器中


最后更新总的点云laserCLoud

好了，截止到现在，我们已经把一帧杂乱的点云数据有条理的放在了容器里，下面就可以开始处理啦！

我们要在laserCloud中找特征点的候选点，该怎么找呢？没错，就是最暴力的方法：遍历每个点（除了前五个和后五个），计算各点曲率并找到所有线的起点终点位置；这一步的代码就是开篇放的那个，就不在重复了。

参照论文对与点位筛选的条件：1. 平面/直线与激光近似平行的点不能要； 2. 被遮挡的边缘点不能要（(b)中点A右侧部分）

.. image:: ../images/dontselectpoint.jpg
   :align: center

有了要求就想办法实现吧，来看代码。遍历所有点（除去前五个和后六个），判断该点及其周边点是否可以作为特征点位：当某点及其后点间的距离平方大于某阈值a（说明这两点有一定距离），且两向量夹角小于某阈值b时（夹角小就可能存在遮挡），将其一侧的临近6个点设为不可标记为特征点的点；若某点到其前后两点的距离均大于c倍的该点深度，则该点判定为不可标记特征点的点（入射角越小，点间距越大，即激光发射方向与投射到的平面越近似水平）。


现在我们得到了一组有条理的点云，且把那些与我们想提取的特征不符的点标记了出来，那我们只需要从剩下的点中选择最好的那一波不就行了！是不是很激动？为了保证特征点均匀的分布在环境中，将一次扫描划分为4个独立的子区域，每个子区域最多提供2个边缘点和4个平面点。我们只需要预先设定好阈值，就可以轻松加随意的将这些点分类了。代码中，把每个线分为6段进行处理，每段都将曲率按照升序排列。看代码：



经过各种折腾终于把这波特征点找到了，后面就是把他们简简单单地发布出去了，简单到我都不想贴代码了。



